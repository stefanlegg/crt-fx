{
  "version": 3,
  "sources": ["../src/core/shaders.ts", "../src/core/pipeline.ts", "../src/effects/scanlines.ts", "../src/effects/phosphor.ts", "../src/effects/chromatic.ts", "../src/effects/bloom.ts", "../src/effects/vignette.ts", "../src/effects/curvature.ts", "../src/effects/noise.ts", "../src/effects/color-bleed.ts", "../src/effects/index.ts", "../src/core/renderer.ts", "../src/export.ts", "../src/presets.ts", "../src/index.ts"],
  "sourcesContent": [
    "/** Shared fullscreen quad vertex shader */\nexport const VERTEX_SHADER = `\nattribute vec2 a_position;\nvarying vec2 v_texCoord;\nvoid main() {\n  v_texCoord = a_position * 0.5 + 0.5;\n  gl_Position = vec4(a_position, 0.0, 1.0);\n}\n`;\n\n/** Passthrough fragment shader (just samples the texture) */\nexport const PASSTHROUGH_FRAGMENT = `\nprecision mediump float;\nvarying vec2 v_texCoord;\nuniform sampler2D u_texture;\nvoid main() {\n  gl_FragColor = texture2D(u_texture, v_texCoord);\n}\n`;\n\n/** Compile a shader from source */\nexport function compileShader(\n  gl: WebGLRenderingContext,\n  type: number,\n  source: string,\n): WebGLShader {\n  const shader = gl.createShader(type);\n  if (!shader) throw new Error('Failed to create shader');\n  gl.shaderSource(shader, source);\n  gl.compileShader(shader);\n  if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {\n    const info = gl.getShaderInfoLog(shader);\n    gl.deleteShader(shader);\n    throw new Error(`Shader compile error: ${info}\\nSource:\\n${source}`);\n  }\n  return shader;\n}\n\n/** Link a program from vertex + fragment shaders */\nexport function createProgram(\n  gl: WebGLRenderingContext,\n  vertexSource: string,\n  fragmentSource: string,\n): WebGLProgram {\n  const vs = compileShader(gl, gl.VERTEX_SHADER, vertexSource);\n  const fs = compileShader(gl, gl.FRAGMENT_SHADER, fragmentSource);\n  const program = gl.createProgram();\n  if (!program) throw new Error('Failed to create program');\n  gl.attachShader(program, vs);\n  gl.attachShader(program, fs);\n  gl.linkProgram(program);\n  if (!gl.getProgramParameter(program, gl.LINK_STATUS)) {\n    const info = gl.getProgramInfoLog(program);\n    gl.deleteProgram(program);\n    throw new Error(`Program link error: ${info}`);\n  }\n  // Shaders can be freed after linking\n  gl.deleteShader(vs);\n  gl.deleteShader(fs);\n  return program;\n}\n",
    "import type { FramebufferInfo, Effect, MultiPassEffect, CompiledPass } from '../types.js';\nimport { VERTEX_SHADER, createProgram } from './shaders.js';\n\nexport class Pipeline {\n  private gl: WebGLRenderingContext;\n  private fbos: FramebufferInfo[] = [];\n  private passes: CompiledPass[] = [];\n  private quadBuffer: WebGLBuffer | null = null;\n  private width = 0;\n  private height = 0;\n\n  constructor(gl: WebGLRenderingContext) {\n    this.gl = gl;\n    this.setupQuad();\n  }\n\n  private setupQuad(): void {\n    const gl = this.gl;\n    this.quadBuffer = gl.createBuffer();\n    gl.bindBuffer(gl.ARRAY_BUFFER, this.quadBuffer);\n    // Fullscreen triangle pair\n    gl.bufferData(\n      gl.ARRAY_BUFFER,\n      new Float32Array([-1, -1, 1, -1, -1, 1, -1, 1, 1, -1, 1, 1]),\n      gl.STATIC_DRAW,\n    );\n  }\n\n  private createFBO(width: number, height: number): FramebufferInfo {\n    const gl = this.gl;\n    const texture = gl.createTexture()!;\n    gl.bindTexture(gl.TEXTURE_2D, texture);\n    gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, width, height, 0, gl.RGBA, gl.UNSIGNED_BYTE, null);\n    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);\n    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR);\n    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);\n    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);\n\n    const framebuffer = gl.createFramebuffer()!;\n    gl.bindFramebuffer(gl.FRAMEBUFFER, framebuffer);\n    gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, texture, 0);\n\n    gl.bindFramebuffer(gl.FRAMEBUFFER, null);\n    gl.bindTexture(gl.TEXTURE_2D, null);\n\n    return { framebuffer, texture };\n  }\n\n  /** Resize all framebuffers */\n  resize(width: number, height: number): void {\n    if (this.width === width && this.height === height) return;\n    this.width = width;\n    this.height = height;\n    this.destroyFBOs();\n    // We need at least 2 for ping-pong, plus extras for bloom\n    // Create enough — we'll use up to 4\n    for (let i = 0; i < 4; i++) {\n      this.fbos.push(this.createFBO(width, height));\n    }\n  }\n\n  private destroyFBOs(): void {\n    const gl = this.gl;\n    for (const fbo of this.fbos) {\n      gl.deleteFramebuffer(fbo.framebuffer);\n      gl.deleteTexture(fbo.texture);\n    }\n    this.fbos = [];\n  }\n\n  /** Build shader programs for the current set of effects */\n  buildPasses(effects: Effect[]): void {\n    const gl = this.gl;\n    // Clean old programs\n    for (const p of this.passes) {\n      gl.deleteProgram(p.program);\n    }\n    this.passes = [];\n\n    for (const effect of effects) {\n      if (isMultiPass(effect)) {\n        for (let i = 0; i < effect.passes; i++) {\n          const frag = effect.getFragmentShader(i);\n          const program = createProgram(gl, VERTEX_SHADER, frag);\n          this.passes.push({ program, effect, passIndex: i });\n        }\n      } else {\n        const program = createProgram(gl, VERTEX_SHADER, effect.fragmentShader);\n        this.passes.push({ program, effect, passIndex: 0 });\n      }\n    }\n  }\n\n  /** Run all passes, reading from sourceTexture, rendering final to canvas */\n  render(\n    sourceTexture: WebGLTexture,\n    params: Record<string, Record<string, any>>,\n    time: number,\n  ): void {\n    const gl = this.gl;\n    if (this.passes.length === 0 || this.fbos.length < 2) return;\n\n    const resolution: [number, number] = [this.width, this.height];\n    let inputTexture = sourceTexture;\n    let pingPong = 0;\n\n    for (let i = 0; i < this.passes.length; i++) {\n      const pass = this.passes[i];\n      const isLast = i === this.passes.length - 1;\n      const effectParams = params[pass.effect.name] || pass.effect.defaultParams;\n\n      if (isLast) {\n        // Render to canvas\n        gl.bindFramebuffer(gl.FRAMEBUFFER, null);\n        gl.viewport(0, 0, gl.drawingBufferWidth, gl.drawingBufferHeight);\n      } else {\n        // Render to FBO\n        const target = this.fbos[pingPong];\n        gl.bindFramebuffer(gl.FRAMEBUFFER, target.framebuffer);\n        gl.viewport(0, 0, this.width, this.height);\n      }\n\n      gl.useProgram(pass.program);\n\n      // Bind input texture\n      gl.activeTexture(gl.TEXTURE0);\n      gl.bindTexture(gl.TEXTURE_2D, inputTexture);\n      const texLoc = gl.getUniformLocation(pass.program, 'u_texture');\n      gl.uniform1i(texLoc, 0);\n\n      // Set effect uniforms\n      if (isMultiPass(pass.effect)) {\n        pass.effect.setPassUniforms(gl, pass.program, effectParams, time, resolution, pass.passIndex);\n      } else {\n        pass.effect.setUniforms(gl, pass.program, effectParams, time, resolution);\n      }\n\n      // Draw quad\n      gl.bindBuffer(gl.ARRAY_BUFFER, this.quadBuffer);\n      const posLoc = gl.getAttribLocation(pass.program, 'a_position');\n      gl.enableVertexAttribArray(posLoc);\n      gl.vertexAttribPointer(posLoc, 2, gl.FLOAT, false, 0, 0);\n      gl.drawArrays(gl.TRIANGLES, 0, 6);\n\n      if (!isLast) {\n        inputTexture = this.fbos[pingPong].texture;\n        pingPong = (pingPong + 1) % this.fbos.length;\n      }\n    }\n  }\n\n  /** Render a passthrough (source directly to canvas) */\n  renderPassthrough(\n    sourceTexture: WebGLTexture,\n    passthroughProgram: WebGLProgram,\n  ): void {\n    const gl = this.gl;\n    gl.bindFramebuffer(gl.FRAMEBUFFER, null);\n    gl.viewport(0, 0, gl.drawingBufferWidth, gl.drawingBufferHeight);\n    gl.useProgram(passthroughProgram);\n    gl.activeTexture(gl.TEXTURE0);\n    gl.bindTexture(gl.TEXTURE_2D, sourceTexture);\n    gl.uniform1i(gl.getUniformLocation(passthroughProgram, 'u_texture'), 0);\n    gl.bindBuffer(gl.ARRAY_BUFFER, this.quadBuffer);\n    const posLoc = gl.getAttribLocation(passthroughProgram, 'a_position');\n    gl.enableVertexAttribArray(posLoc);\n    gl.vertexAttribPointer(posLoc, 2, gl.FLOAT, false, 0, 0);\n    gl.drawArrays(gl.TRIANGLES, 0, 6);\n  }\n\n  dispose(): void {\n    const gl = this.gl;\n    this.destroyFBOs();\n    for (const p of this.passes) {\n      gl.deleteProgram(p.program);\n    }\n    this.passes = [];\n    if (this.quadBuffer) {\n      gl.deleteBuffer(this.quadBuffer);\n      this.quadBuffer = null;\n    }\n  }\n}\n\nfunction isMultiPass(effect: Effect): effect is MultiPassEffect {\n  return 'passes' in effect && typeof (effect as any).passes === 'number';\n}\n\nexport type { MultiPassEffect };\n",
    "import type { Effect } from '../types.js';\n\nexport const scanlines: Effect = {\n  name: 'scanlines',\n\n  defaultParams: {\n    intensity: 0.5,\n    count: 800,\n    sharpness: 0.5,\n    phase: 0,\n  },\n\n  fragmentShader: `\nprecision mediump float;\nvarying vec2 v_texCoord;\nuniform sampler2D u_texture;\nuniform float u_intensity;\nuniform float u_count;\nuniform float u_sharpness;\nuniform float u_phase;\nuniform vec2 u_resolution;\n\nvoid main() {\n  vec4 color = texture2D(u_texture, v_texCoord);\n\n  // Scanline pattern: sine wave along Y axis\n  float y = v_texCoord.y * u_count + u_phase;\n  float scanline = sin(y * 3.14159265) * 0.5 + 0.5;\n\n  // Sharpen the sine wave using pow — higher sharpness = harder edges\n  scanline = pow(scanline, mix(0.5, 4.0, u_sharpness));\n\n  // Mix between full color and darkened scanline\n  float mask = 1.0 - u_intensity * (1.0 - scanline);\n\n  gl_FragColor = vec4(color.rgb * mask, color.a);\n}\n`,\n\n  setUniforms(gl, program, params, time, resolution) {\n    gl.uniform1f(gl.getUniformLocation(program, 'u_intensity'), params.intensity ?? 0.5);\n    gl.uniform1f(gl.getUniformLocation(program, 'u_count'), params.count ?? 800);\n    gl.uniform1f(gl.getUniformLocation(program, 'u_sharpness'), params.sharpness ?? 0.5);\n    gl.uniform1f(gl.getUniformLocation(program, 'u_phase'), (params.phase ?? 0) + time * 0.5);\n    gl.uniform2f(gl.getUniformLocation(program, 'u_resolution'), resolution[0], resolution[1]);\n  },\n};\n",
    "import type { Effect } from '../types.js';\n\nexport const phosphor: Effect = {\n  name: 'phosphor',\n\n  defaultParams: {\n    style: 'shadow-mask',\n    scale: 1.0,\n    intensity: 0.5,\n  },\n\n  fragmentShader: `\nprecision mediump float;\nvarying vec2 v_texCoord;\nuniform sampler2D u_texture;\nuniform int u_style;\nuniform float u_scale;\nuniform float u_intensity;\nuniform vec2 u_resolution;\n\n// Phosphor style constants\nconst int SHADOW_MASK    = 0;\nconst int APERTURE_GRILLE = 1;\nconst int SLOT_MASK      = 2;\nconst int CROMACLEAR     = 3;\nconst int PVM            = 4;\nconst int ARCADE         = 5;\nconst int VGA            = 6;\nconst int COMPOSITE      = 7;\nconst int MONO_GREEN     = 8;\nconst int MONO_AMBER     = 9;\n\nfloat luminance(vec3 c) {\n  return dot(c, vec3(0.2126, 0.7152, 0.0722));\n}\n\nvec3 shadowMask(vec2 fragCoord, float scale) {\n  float cellW = 3.0 * scale;\n  float cellH = 3.0 * scale;\n  vec2 pos = fragCoord;\n  // Offset every other row\n  float row = floor(pos.y / cellH);\n  if (mod(row, 2.0) > 0.5) {\n    pos.x += cellW * 0.5;\n  }\n  float col = mod(pos.x, cellW);\n  float phase = col / cellW;\n  vec3 mask = vec3(0.2);\n  if (phase < 0.333) {\n    mask.r = 1.0;\n    mask.g = 0.3;\n    mask.b = 0.3;\n  } else if (phase < 0.666) {\n    mask.r = 0.3;\n    mask.g = 1.0;\n    mask.b = 0.3;\n  } else {\n    mask.r = 0.3;\n    mask.g = 0.3;\n    mask.b = 1.0;\n  }\n  // Circular dot shape\n  vec2 cellPos = vec2(mod(pos.x, cellW) / cellW, mod(pos.y, cellH) / cellH);\n  float dist = length(cellPos - 0.5) * 2.0;\n  float dot = smoothstep(1.0, 0.3, dist);\n  return mix(vec3(0.1), mask, dot);\n}\n\nvec3 apertureGrille(vec2 fragCoord, float scale) {\n  float cellW = 3.0 * scale;\n  float col = mod(fragCoord.x, cellW);\n  float phase = col / cellW;\n  vec3 mask = vec3(0.0);\n  if (phase < 0.333) {\n    mask = vec3(1.0, 0.15, 0.15);\n  } else if (phase < 0.666) {\n    mask = vec3(0.15, 1.0, 0.15);\n  } else {\n    mask = vec3(0.15, 0.15, 1.0);\n  }\n  return mask;\n}\n\nvec3 slotMask(vec2 fragCoord, float scale) {\n  float cellW = 3.0 * scale;\n  float cellH = 4.0 * scale;\n  vec2 pos = fragCoord;\n  float row = floor(pos.y / cellH);\n  if (mod(row, 2.0) > 0.5) {\n    pos.x += cellW * 0.5;\n  }\n  float col = mod(pos.x, cellW);\n  float phase = col / cellW;\n  // Slot shape — rectangular with gap\n  float slotY = mod(pos.y, cellH) / cellH;\n  float slotMask = step(0.15, slotY) * step(slotY, 0.85);\n  vec3 mask = vec3(0.1);\n  if (phase < 0.333) {\n    mask = vec3(1.0, 0.1, 0.1);\n  } else if (phase < 0.666) {\n    mask = vec3(0.1, 1.0, 0.1);\n  } else {\n    mask = vec3(0.1, 0.1, 1.0);\n  }\n  return mix(vec3(0.1), mask, slotMask);\n}\n\nvec3 cromaclear(vec2 fragCoord, float scale) {\n  float cellW = 3.0 * scale;\n  float cellH = 2.0 * scale;\n  float col = mod(fragCoord.x, cellW);\n  float phase = col / cellW;\n  // Elliptical shape\n  vec2 cellPos = vec2(mod(fragCoord.x, cellW) / cellW, mod(fragCoord.y, cellH) / cellH);\n  float ex = (cellPos.x - 0.5) * 2.0;\n  float ey = (cellPos.y - 0.5) * 1.5;\n  float ellipse = smoothstep(1.0, 0.4, length(vec2(ex, ey)));\n  vec3 mask = vec3(0.1);\n  if (phase < 0.333) {\n    mask = vec3(1.0, 0.1, 0.1);\n  } else if (phase < 0.666) {\n    mask = vec3(0.1, 1.0, 0.1);\n  } else {\n    mask = vec3(0.1, 0.1, 1.0);\n  }\n  return mix(vec3(0.1), mask, ellipse);\n}\n\nvec3 pvmMask(vec2 fragCoord, float scale) {\n  // Ultra-fine aperture grille\n  float cellW = 2.0 * scale;\n  float col = mod(fragCoord.x, cellW);\n  float phase = col / cellW;\n  vec3 mask = vec3(0.0);\n  if (phase < 0.333) {\n    mask = vec3(1.0, 0.2, 0.2);\n  } else if (phase < 0.666) {\n    mask = vec3(0.2, 1.0, 0.2);\n  } else {\n    mask = vec3(0.2, 0.2, 1.0);\n  }\n  return mask;\n}\n\nvec3 arcadeMask(vec2 fragCoord, float scale) {\n  // Large coarse dot triads\n  float cellW = 6.0 * scale;\n  float cellH = 6.0 * scale;\n  vec2 pos = fragCoord;\n  float row = floor(pos.y / cellH);\n  if (mod(row, 2.0) > 0.5) {\n    pos.x += cellW * 0.5;\n  }\n  float col = mod(pos.x, cellW);\n  float phase = col / cellW;\n  vec2 cellPos = vec2(mod(pos.x, cellW) / cellW, mod(pos.y, cellH) / cellH);\n  float dist = length(cellPos - 0.5) * 2.0;\n  float dot = smoothstep(1.0, 0.2, dist);\n  vec3 mask = vec3(0.0);\n  if (phase < 0.333) {\n    mask = vec3(1.0, 0.0, 0.0);\n  } else if (phase < 0.666) {\n    mask = vec3(0.0, 1.0, 0.0);\n  } else {\n    mask = vec3(0.0, 0.0, 1.0);\n  }\n  return mix(vec3(0.02), mask, dot);\n}\n\nvec3 vgaMask(vec2 fragCoord, float scale) {\n  // Medium-pitch shadow mask with sharp edges\n  float cellW = 4.0 * scale;\n  float cellH = 4.0 * scale;\n  vec2 pos = fragCoord;\n  float row = floor(pos.y / cellH);\n  if (mod(row, 2.0) > 0.5) {\n    pos.x += cellW * 0.5;\n  }\n  float col = mod(pos.x, cellW);\n  float phase = col / cellW;\n  // Sharp rectangular subpixels\n  vec2 cellPos = vec2(mod(pos.x, cellW) / cellW, mod(pos.y, cellH) / cellH);\n  float inCell = step(0.1, cellPos.x) * step(cellPos.x, 0.9) * step(0.1, cellPos.y) * step(cellPos.y, 0.9);\n  vec3 mask = vec3(0.05);\n  if (phase < 0.333) {\n    mask = vec3(1.0, 0.1, 0.1);\n  } else if (phase < 0.666) {\n    mask = vec3(0.1, 1.0, 0.1);\n  } else {\n    mask = vec3(0.1, 0.1, 1.0);\n  }\n  return mix(vec3(0.05), mask, inCell);\n}\n\nvec3 compositeMask(vec2 fragCoord, float scale) {\n  // Soft/blurred shadow mask\n  float cellW = 3.0 * scale;\n  float cellH = 3.0 * scale;\n  vec2 pos = fragCoord;\n  float row = floor(pos.y / cellH);\n  if (mod(row, 2.0) > 0.5) {\n    pos.x += cellW * 0.5;\n  }\n  float col = mod(pos.x, cellW);\n  float phase = col / cellW;\n  vec2 cellPos = vec2(mod(pos.x, cellW) / cellW, mod(pos.y, cellH) / cellH);\n  float dist = length(cellPos - 0.5) * 2.0;\n  // Very soft/blurred dot\n  float dot = smoothstep(1.5, 0.0, dist);\n  vec3 mask = vec3(0.2);\n  if (phase < 0.333) {\n    mask = vec3(1.0, 0.3, 0.3);\n  } else if (phase < 0.666) {\n    mask = vec3(0.3, 1.0, 0.3);\n  } else {\n    mask = vec3(0.3, 0.3, 1.0);\n  }\n  return mix(vec3(0.2), mask, dot);\n}\n\nvoid main() {\n  vec4 color = texture2D(u_texture, v_texCoord);\n  vec2 fragCoord = v_texCoord * u_resolution;\n\n  vec3 mask = vec3(1.0);\n\n  if (u_style == SHADOW_MASK) {\n    mask = shadowMask(fragCoord, u_scale);\n  } else if (u_style == APERTURE_GRILLE) {\n    mask = apertureGrille(fragCoord, u_scale);\n  } else if (u_style == SLOT_MASK) {\n    mask = slotMask(fragCoord, u_scale);\n  } else if (u_style == CROMACLEAR) {\n    mask = cromaclear(fragCoord, u_scale);\n  } else if (u_style == PVM) {\n    mask = pvmMask(fragCoord, u_scale);\n  } else if (u_style == ARCADE) {\n    mask = arcadeMask(fragCoord, u_scale);\n  } else if (u_style == VGA) {\n    mask = vgaMask(fragCoord, u_scale);\n  } else if (u_style == COMPOSITE) {\n    mask = compositeMask(fragCoord, u_scale);\n  } else if (u_style == MONO_GREEN) {\n    // Single green phosphor\n    float lum = luminance(color.rgb);\n    color.rgb = vec3(lum * 0.2, lum, lum * 0.2) * vec3(0.2, 1.0, 0.133);\n    mask = vec3(1.0);\n  } else if (u_style == MONO_AMBER) {\n    // Single amber phosphor\n    float lum = luminance(color.rgb);\n    color.rgb = vec3(lum, lum * 0.69, lum * 0.0) * vec3(1.0, 0.69, 0.0);\n    mask = vec3(1.0);\n  }\n\n  // Blend phosphor mask with intensity\n  vec3 result = color.rgb * mix(vec3(1.0), mask, u_intensity);\n\n  gl_FragColor = vec4(result, color.a);\n}\n`,\n\n  setUniforms(gl, program, params, _time, resolution) {\n    const styleMap: Record<string, number> = {\n      'shadow-mask': 0,\n      'aperture-grille': 1,\n      'slot-mask': 2,\n      'cromaclear': 3,\n      'pvm': 4,\n      'arcade': 5,\n      'vga': 6,\n      'composite': 7,\n      'mono-green': 8,\n      'mono-amber': 9,\n    };\n    const styleIdx = styleMap[params.style as string] ?? 0;\n    gl.uniform1i(gl.getUniformLocation(program, 'u_style'), styleIdx);\n    gl.uniform1f(gl.getUniformLocation(program, 'u_scale'), params.scale ?? 1.0);\n    gl.uniform1f(gl.getUniformLocation(program, 'u_intensity'), params.intensity ?? 0.5);\n    gl.uniform2f(gl.getUniformLocation(program, 'u_resolution'), resolution[0], resolution[1]);\n  },\n};\n",
    "import type { Effect } from '../types.js';\n\nexport const chromatic: Effect = {\n  name: 'chromatic',\n\n  defaultParams: {\n    offset: 2.0,\n    angle: 0,\n  },\n\n  fragmentShader: `\nprecision mediump float;\nvarying vec2 v_texCoord;\nuniform sampler2D u_texture;\nuniform float u_offset;\nuniform float u_angle;\nuniform vec2 u_resolution;\n\nvoid main() {\n  // Direction from center to current pixel\n  vec2 center = vec2(0.5);\n  vec2 dir = v_texCoord - center;\n\n  // Offset in pixels, converted to UV space\n  vec2 offsetDir;\n  if (u_angle == 0.0) {\n    offsetDir = normalize(dir + vec2(0.0001));\n  } else {\n    float a = u_angle * 3.14159265 / 180.0;\n    offsetDir = vec2(cos(a), sin(a));\n  }\n\n  vec2 texelSize = 1.0 / u_resolution;\n  vec2 off = offsetDir * u_offset * texelSize;\n\n  // Sample R, G, B at different offsets\n  float r = texture2D(u_texture, v_texCoord + off).r;\n  float g = texture2D(u_texture, v_texCoord).g;\n  float b = texture2D(u_texture, v_texCoord - off).b;\n  float a = texture2D(u_texture, v_texCoord).a;\n\n  gl_FragColor = vec4(r, g, b, a);\n}\n`,\n\n  setUniforms(gl, program, params, _time, resolution) {\n    gl.uniform1f(gl.getUniformLocation(program, 'u_offset'), params.offset ?? 2.0);\n    gl.uniform1f(gl.getUniformLocation(program, 'u_angle'), params.angle ?? 0);\n    gl.uniform2f(gl.getUniformLocation(program, 'u_resolution'), resolution[0], resolution[1]);\n  },\n};\n",
    "import type { Effect } from '../types.js';\n\nexport const bloom: Effect = {\n  name: 'bloom',\n\n  defaultParams: {\n    radius: 4,\n    strength: 0.3,\n    threshold: 0.7,\n  },\n\n  fragmentShader: `\nprecision mediump float;\nvarying vec2 v_texCoord;\nuniform sampler2D u_texture;\nuniform float u_radius;\nuniform float u_strength;\nuniform float u_threshold;\nuniform vec2 u_resolution;\n\nvoid main() {\n  vec4 original = texture2D(u_texture, v_texCoord);\n  vec2 texelSize = 1.0 / u_resolution;\n\n  // Two-pass gaussian approximation combined in single pass\n  // Sample in a cross/star pattern for efficiency\n  vec3 bloomColor = vec3(0.0);\n  float totalWeight = 0.0;\n\n  // Sample radius in texels\n  float r = u_radius;\n\n  for (int i = -12; i <= 12; i++) {\n    for (int j = -12; j <= 12; j++) {\n      float fi = float(i);\n      float fj = float(j);\n      if (abs(fi) > r || abs(fj) > r) continue;\n\n      // Skip corners for diamond/circular pattern (faster)\n      if (fi * fi + fj * fj > r * r) continue;\n\n      vec2 offset = vec2(fi, fj) * texelSize;\n      vec4 samp = texture2D(u_texture, v_texCoord + offset);\n\n      float brightness = dot(samp.rgb, vec3(0.2126, 0.7152, 0.0722));\n      if (brightness < u_threshold) continue;\n\n      float weight = exp(-0.5 * (fi * fi + fj * fj) / (r * r * 0.25 + 0.001));\n      bloomColor += samp.rgb * weight * (brightness - u_threshold);\n      totalWeight += weight;\n    }\n  }\n\n  if (totalWeight > 0.0) {\n    bloomColor /= totalWeight;\n  }\n\n  // Composite bloom onto original\n  vec3 result = original.rgb + bloomColor * u_strength;\n  gl_FragColor = vec4(result, original.a);\n}\n`,\n\n  setUniforms(gl, program, params, _time, resolution) {\n    gl.uniform1f(gl.getUniformLocation(program, 'u_radius'), params.radius ?? 4);\n    gl.uniform1f(gl.getUniformLocation(program, 'u_strength'), params.strength ?? 0.3);\n    gl.uniform1f(gl.getUniformLocation(program, 'u_threshold'), params.threshold ?? 0.7);\n    gl.uniform2f(gl.getUniformLocation(program, 'u_resolution'), resolution[0], resolution[1]);\n  },\n};\n",
    "import type { Effect } from '../types.js';\n\nexport const vignette: Effect = {\n  name: 'vignette',\n\n  defaultParams: {\n    strength: 0.3,\n    radius: 0.8,\n  },\n\n  fragmentShader: `\nprecision mediump float;\nvarying vec2 v_texCoord;\nuniform sampler2D u_texture;\nuniform float u_strength;\nuniform float u_radius;\n\nvoid main() {\n  vec4 color = texture2D(u_texture, v_texCoord);\n\n  // Distance from center (0,0 at center, ~1.0 at corners)\n  vec2 uv = v_texCoord * 2.0 - 1.0;\n  float dist = length(uv);\n\n  // Smooth vignette falloff\n  float vig = smoothstep(u_radius, u_radius + (1.0 - u_radius) * 1.2, dist);\n  float factor = 1.0 - vig * u_strength;\n\n  gl_FragColor = vec4(color.rgb * factor, color.a);\n}\n`,\n\n  setUniforms(gl, program, params) {\n    gl.uniform1f(gl.getUniformLocation(program, 'u_strength'), params.strength ?? 0.3);\n    gl.uniform1f(gl.getUniformLocation(program, 'u_radius'), params.radius ?? 0.8);\n  },\n};\n",
    "import type { Effect } from '../types.js';\n\nexport const curvature: Effect = {\n  name: 'curvature',\n\n  defaultParams: {\n    amount: 0.02,\n  },\n\n  fragmentShader: `\nprecision mediump float;\nvarying vec2 v_texCoord;\nuniform sampler2D u_texture;\nuniform float u_amount;\n\nvec2 barrelDistortion(vec2 uv, float k) {\n  // Convert to centered coordinates (-1 to 1)\n  vec2 centered = uv * 2.0 - 1.0;\n\n  // Apply barrel distortion\n  float r2 = dot(centered, centered);\n  vec2 distorted = centered * (1.0 + k * r2 + k * k * r2 * r2);\n\n  // Convert back to 0-1 range\n  return distorted * 0.5 + 0.5;\n}\n\nvoid main() {\n  vec2 uv = barrelDistortion(v_texCoord, u_amount);\n\n  // Black outside the curved screen area\n  if (uv.x < 0.0 || uv.x > 1.0 || uv.y < 0.0 || uv.y > 1.0) {\n    gl_FragColor = vec4(0.0, 0.0, 0.0, 1.0);\n    return;\n  }\n\n  gl_FragColor = texture2D(u_texture, uv);\n}\n`,\n\n  setUniforms(gl, program, params) {\n    gl.uniform1f(gl.getUniformLocation(program, 'u_amount'), params.amount ?? 0.02);\n  },\n};\n",
    "import type { Effect } from '../types.js';\n\nexport const noise: Effect = {\n  name: 'noise',\n\n  defaultParams: {\n    intensity: 0.05,\n    flickerIntensity: 0.03,\n    speed: 1.0,\n  },\n\n  fragmentShader: `\nprecision mediump float;\nvarying vec2 v_texCoord;\nuniform sampler2D u_texture;\nuniform float u_intensity;\nuniform float u_flickerIntensity;\nuniform float u_speed;\nuniform float u_time;\nuniform vec2 u_resolution;\n\n// Pseudo-random hash\nfloat hash(vec2 p) {\n  vec3 p3 = fract(vec3(p.xyx) * 0.1031);\n  p3 += dot(p3, p3.yzx + 33.33);\n  return fract((p3.x + p3.y) * p3.z);\n}\n\n// Smooth noise\nfloat noise2d(vec2 p) {\n  vec2 i = floor(p);\n  vec2 f = fract(p);\n  f = f * f * (3.0 - 2.0 * f); // smoothstep\n  float a = hash(i);\n  float b = hash(i + vec2(1.0, 0.0));\n  float c = hash(i + vec2(0.0, 1.0));\n  float d = hash(i + vec2(1.0, 1.0));\n  return mix(mix(a, b, f.x), mix(c, d, f.x), f.y);\n}\n\nvoid main() {\n  vec4 color = texture2D(u_texture, v_texCoord);\n\n  // Animated noise grain\n  float time = u_time * u_speed;\n  vec2 noiseCoord = v_texCoord * u_resolution;\n  float n = hash(noiseCoord + vec2(time * 127.1, time * 311.7));\n\n  // Apply noise\n  vec3 grain = vec3(n * 2.0 - 1.0) * u_intensity;\n  color.rgb += grain;\n\n  // Flicker: global brightness variation\n  float flicker = 1.0 + (hash(vec2(floor(time * 15.0), 0.0)) * 2.0 - 1.0) * u_flickerIntensity;\n  color.rgb *= flicker;\n\n  gl_FragColor = vec4(clamp(color.rgb, 0.0, 1.0), color.a);\n}\n`,\n\n  setUniforms(gl, program, params, time, resolution) {\n    gl.uniform1f(gl.getUniformLocation(program, 'u_intensity'), params.intensity ?? 0.05);\n    gl.uniform1f(\n      gl.getUniformLocation(program, 'u_flickerIntensity'),\n      params.flickerIntensity ?? 0.03,\n    );\n    gl.uniform1f(gl.getUniformLocation(program, 'u_speed'), params.speed ?? 1.0);\n    gl.uniform1f(gl.getUniformLocation(program, 'u_time'), time);\n    gl.uniform2f(gl.getUniformLocation(program, 'u_resolution'), resolution[0], resolution[1]);\n  },\n};\n",
    "import type { Effect } from '../types.js';\n\nexport const colorBleed: Effect = {\n  name: 'colorBleed',\n\n  defaultParams: {\n    amount: 0.003,\n    direction: 0,\n  },\n\n  fragmentShader: `\nprecision mediump float;\nvarying vec2 v_texCoord;\nuniform sampler2D u_texture;\nuniform float u_amount;\nuniform float u_direction;\nuniform vec2 u_resolution;\n\nvoid main() {\n  vec4 center = texture2D(u_texture, v_texCoord);\n  vec2 texelSize = 1.0 / u_resolution;\n\n  // Horizontal color bleeding - sample neighbors and smear color\n  float bleedPixels = u_amount * u_resolution.x;\n\n  // Direction: 0 = horizontal (left-to-right), 1 = vertical\n  vec2 dir;\n  if (u_direction < 0.5) {\n    dir = vec2(1.0, 0.0);\n  } else {\n    dir = vec2(0.0, 1.0);\n  }\n\n  // Accumulate weighted color from neighbors (asymmetric - more from left/above)\n  vec3 bleed = center.rgb;\n  float totalWeight = 1.0;\n\n  // Sample previous pixels (trailing bleed)\n  for (int i = 1; i <= 8; i++) {\n    float fi = float(i);\n    if (fi > bleedPixels * 10.0) break;\n\n    float weight = exp(-fi * 0.5 / (bleedPixels * 3.0 + 0.001));\n    vec2 offset = -dir * fi * texelSize;\n    vec3 samp = texture2D(u_texture, v_texCoord + offset).rgb;\n\n    bleed += samp * weight;\n    totalWeight += weight;\n  }\n\n  bleed /= totalWeight;\n\n  // Mix bleeding with original\n  float mixAmt = clamp(u_amount * 10.0, 0.0, 1.0);\n  vec3 result = mix(center.rgb, bleed, mixAmt);\n\n  gl_FragColor = vec4(result, center.a);\n}\n`,\n\n  setUniforms(gl, program, params, _time, resolution) {\n    gl.uniform1f(gl.getUniformLocation(program, 'u_amount'), params.amount ?? 0.003);\n    gl.uniform1f(gl.getUniformLocation(program, 'u_direction'), params.direction ?? 0);\n    gl.uniform2f(gl.getUniformLocation(program, 'u_resolution'), resolution[0], resolution[1]);\n  },\n};\n",
    "import type { Effect } from '../types.js';\nimport { scanlines } from './scanlines.js';\nimport { phosphor } from './phosphor.js';\nimport { chromatic } from './chromatic.js';\nimport { bloom } from './bloom.js';\nimport { vignette } from './vignette.js';\nimport { curvature } from './curvature.js';\nimport { noise } from './noise.js';\nimport { colorBleed } from './color-bleed.js';\n\nexport { scanlines, phosphor, chromatic, bloom, vignette, curvature, noise, colorBleed };\n\n/** All effects in recommended pipeline order */\nexport const allEffects: Effect[] = [\n  curvature,\n  colorBleed,\n  chromatic,\n  phosphor,\n  scanlines,\n  noise,\n  bloom,\n  vignette,\n];\n",
    "import type { Effect, ImageSource, CRTOptions } from '../types.js';\nimport { Pipeline } from './pipeline.js';\nimport { VERTEX_SHADER, PASSTHROUGH_FRAGMENT, createProgram } from './shaders.js';\nimport { allEffects } from '../effects/index.js';\n\nexport class Renderer {\n  public canvas: HTMLCanvasElement;\n  public gl: WebGLRenderingContext;\n  private pipeline: Pipeline;\n  private sourceTexture: WebGLTexture | null = null;\n  private passthroughProgram: WebGLProgram;\n  private animFrameId: number | null = null;\n  private startTime = 0;\n  private params: Record<string, Record<string, any>> = {};\n  private activeEffects: Effect[] = [];\n  private imageWidth = 0;\n  private imageHeight = 0;\n  private contextLost = false;\n  private onContextLost: (e: Event) => void;\n  private onContextRestored: (e: Event) => void;\n  private resizeObserver: ResizeObserver | null = null;\n\n  constructor(canvas: HTMLCanvasElement, options: CRTOptions = {}) {\n    this.canvas = canvas;\n    const gl = canvas.getContext('webgl', {\n      alpha: false,\n      premultipliedAlpha: false,\n      preserveDrawingBuffer: true,\n      antialias: false,\n    });\n    if (!gl) throw new Error('WebGL not supported');\n    this.gl = gl;\n\n    this.pipeline = new Pipeline(gl);\n    this.passthroughProgram = createProgram(gl, VERTEX_SHADER, PASSTHROUGH_FRAGMENT);\n\n    // Apply options\n    this.setOptions(options);\n\n    // Context loss handling\n    this.onContextLost = (e: Event) => {\n      e.preventDefault();\n      this.contextLost = true;\n      if (this.animFrameId !== null) {\n        cancelAnimationFrame(this.animFrameId);\n        this.animFrameId = null;\n      }\n    };\n    this.onContextRestored = () => {\n      this.contextLost = false;\n      this.rebuildAll();\n    };\n    canvas.addEventListener('webglcontextlost', this.onContextLost);\n    canvas.addEventListener('webglcontextrestored', this.onContextRestored);\n\n    // Observe resize\n    this.resizeObserver = new ResizeObserver(() => this.handleResize());\n    this.resizeObserver.observe(canvas);\n  }\n\n  private handleResize(): void {\n    const dpr = window.devicePixelRatio || 1;\n    const rect = this.canvas.getBoundingClientRect();\n    const w = Math.round(rect.width * dpr);\n    const h = Math.round(rect.height * dpr);\n    if (this.canvas.width !== w || this.canvas.height !== h) {\n      this.canvas.width = w;\n      this.canvas.height = h;\n      if (this.imageWidth > 0) {\n        this.pipeline.resize(this.imageWidth, this.imageHeight);\n      }\n    }\n  }\n\n  setOptions(options: CRTOptions): void {\n    // Map option keys → effect instances & params\n    const effectMap: Record<string, Effect> = {};\n    for (const e of allEffects) {\n      effectMap[e.name] = e;\n    }\n\n    this.params = {};\n    this.activeEffects = [];\n\n    // Determine which effects are enabled and build params\n    const effectOrder = [\n      'curvature',\n      'colorBleed',\n      'chromatic',\n      'phosphor',\n      'scanlines',\n      'noise',\n      'bloom',\n      'vignette',\n    ];\n\n    for (const name of effectOrder) {\n      const opts = (options as any)[name];\n      if (opts === undefined) continue;\n      if (opts.enabled === false) continue;\n\n      const effect = effectMap[name];\n      if (!effect) continue;\n\n      this.params[name] = { ...effect.defaultParams, ...opts };\n      this.activeEffects.push(effect);\n    }\n\n    // Rebuild pipeline\n    if (!this.contextLost) {\n      this.pipeline.buildPasses(this.activeEffects);\n    }\n  }\n\n  updateParams(options: CRTOptions): void {\n    // Deep merge into existing params\n    for (const [key, val] of Object.entries(options)) {\n      if (val === undefined) continue;\n      if (typeof val === 'object' && val !== null) {\n        if ((val as any).enabled === false) {\n          // Remove effect\n          delete this.params[key];\n          this.activeEffects = this.activeEffects.filter((e) => e.name !== key);\n        } else if (this.params[key]) {\n          // Merge\n          Object.assign(this.params[key], val);\n        } else {\n          // Add new effect\n          const effectMap: Record<string, Effect> = {};\n          for (const e of allEffects) effectMap[e.name] = e;\n          const effect = effectMap[key];\n          if (effect) {\n            this.params[key] = { ...effect.defaultParams, ...(val as any) };\n            this.activeEffects.push(effect);\n          }\n        }\n      }\n    }\n    if (!this.contextLost) {\n      this.pipeline.buildPasses(this.activeEffects);\n    }\n  }\n\n  async loadImage(source: ImageSource): Promise<void> {\n    const gl = this.gl;\n    let img: TexImageSource;\n\n    if (typeof source === 'string') {\n      img = await loadImageFromURL(source);\n    } else if (source instanceof File || source instanceof Blob) {\n      const url = URL.createObjectURL(source);\n      try {\n        img = await loadImageFromURL(url);\n      } finally {\n        URL.revokeObjectURL(url);\n      }\n    } else if (source instanceof ImageData) {\n      // Convert to canvas\n      const c = document.createElement('canvas');\n      c.width = source.width;\n      c.height = source.height;\n      const ctx = c.getContext('2d')!;\n      ctx.putImageData(source, 0, 0);\n      img = c;\n    } else {\n      img = source as TexImageSource;\n    }\n\n    // Get dimensions\n    if (img instanceof HTMLImageElement) {\n      this.imageWidth = img.naturalWidth;\n      this.imageHeight = img.naturalHeight;\n    } else if (img instanceof HTMLCanvasElement) {\n      this.imageWidth = img.width;\n      this.imageHeight = img.height;\n    } else if (img instanceof ImageBitmap) {\n      this.imageWidth = img.width;\n      this.imageHeight = img.height;\n    } else {\n      this.imageWidth = (img as any).width || this.canvas.width;\n      this.imageHeight = (img as any).height || this.canvas.height;\n    }\n\n    // Upload texture\n    if (this.sourceTexture) {\n      gl.deleteTexture(this.sourceTexture);\n    }\n    this.sourceTexture = gl.createTexture();\n    gl.bindTexture(gl.TEXTURE_2D, this.sourceTexture);\n    gl.pixelStorei(gl.UNPACK_FLIP_Y_WEBGL, 1);\n    gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, img);\n    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);\n    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR);\n    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);\n    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);\n    gl.bindTexture(gl.TEXTURE_2D, null);\n\n    this.pipeline.resize(this.imageWidth, this.imageHeight);\n    this.renderFrame(0);\n  }\n\n  private renderFrame(time: number): void {\n    if (this.contextLost || !this.sourceTexture) return;\n    const gl = this.gl;\n\n    gl.clearColor(0, 0, 0, 1);\n    gl.clear(gl.COLOR_BUFFER_BIT);\n\n    if (this.activeEffects.length === 0) {\n      this.pipeline.renderPassthrough(this.sourceTexture, this.passthroughProgram);\n    } else {\n      this.pipeline.render(this.sourceTexture, this.params, time);\n    }\n  }\n\n  start(): void {\n    if (this.animFrameId !== null) return;\n    this.startTime = performance.now();\n    const loop = (now: number) => {\n      const t = (now - this.startTime) / 1000;\n      this.renderFrame(t);\n      this.animFrameId = requestAnimationFrame(loop);\n    };\n    this.animFrameId = requestAnimationFrame(loop);\n  }\n\n  stop(): void {\n    if (this.animFrameId !== null) {\n      cancelAnimationFrame(this.animFrameId);\n      this.animFrameId = null;\n    }\n  }\n\n  /** Render a single frame (for static export) */\n  renderOnce(): void {\n    this.renderFrame(performance.now() / 1000);\n  }\n\n  private rebuildAll(): void {\n    this.passthroughProgram = createProgram(this.gl, VERTEX_SHADER, PASSTHROUGH_FRAGMENT);\n    this.pipeline = new Pipeline(this.gl);\n    if (this.imageWidth > 0) {\n      this.pipeline.resize(this.imageWidth, this.imageHeight);\n    }\n    this.pipeline.buildPasses(this.activeEffects);\n  }\n\n  dispose(): void {\n    this.stop();\n    this.canvas.removeEventListener('webglcontextlost', this.onContextLost);\n    this.canvas.removeEventListener('webglcontextrestored', this.onContextRestored);\n    if (this.resizeObserver) {\n      this.resizeObserver.disconnect();\n      this.resizeObserver = null;\n    }\n    const gl = this.gl;\n    this.pipeline.dispose();\n    if (this.sourceTexture) {\n      gl.deleteTexture(this.sourceTexture);\n      this.sourceTexture = null;\n    }\n    gl.deleteProgram(this.passthroughProgram);\n  }\n}\n\nfunction loadImageFromURL(url: string): Promise<HTMLImageElement> {\n  return new Promise((resolve, reject) => {\n    const img = new Image();\n    img.crossOrigin = 'anonymous';\n    img.onload = () => resolve(img);\n    img.onerror = () => reject(new Error(`Failed to load image: ${url}`));\n    img.src = url;\n  });\n}\n",
    "/** Export the current canvas state to various formats */\n\nexport function exportDataURL(\n  canvas: HTMLCanvasElement,\n  mimeType: string = 'image/png',\n  quality?: number,\n): string {\n  return canvas.toDataURL(mimeType, quality);\n}\n\nexport function exportBlob(\n  canvas: HTMLCanvasElement,\n  mimeType: string = 'image/png',\n  quality?: number,\n): Promise<Blob> {\n  return new Promise((resolve, reject) => {\n    canvas.toBlob(\n      (blob) => {\n        if (blob) resolve(blob);\n        else reject(new Error('Failed to export canvas to blob'));\n      },\n      mimeType,\n      quality,\n    );\n  });\n}\n\nexport function exportToCanvas(\n  sourceCanvas: HTMLCanvasElement,\n  targetCanvas?: HTMLCanvasElement,\n): HTMLCanvasElement {\n  const target = targetCanvas || document.createElement('canvas');\n  target.width = sourceCanvas.width;\n  target.height = sourceCanvas.height;\n  const ctx = target.getContext('2d')!;\n  ctx.drawImage(sourceCanvas, 0, 0);\n  return target;\n}\n",
    "import type { CRTOptions } from './types.js';\n\nexport const presets: Record<string, CRTOptions> = {\n  trinitron: {\n    phosphor: { style: 'aperture-grille', scale: 1.0, intensity: 0.4 },\n    scanlines: { intensity: 0.3, count: 800, sharpness: 0.4 },\n    bloom: { radius: 3, strength: 0.2, threshold: 0.8 },\n    chromatic: { offset: 1.0 },\n    vignette: { strength: 0.15, radius: 0.85 },\n    curvature: { amount: 0.01 },\n    noise: { intensity: 0.01, flickerIntensity: 0.01 },\n  },\n\n  arcade: {\n    phosphor: { style: 'arcade', scale: 1.5, intensity: 0.7 },\n    scanlines: { intensity: 0.8, count: 600, sharpness: 0.7 },\n    bloom: { radius: 5, strength: 0.4, threshold: 0.6 },\n    chromatic: { offset: 3.0 },\n    vignette: { strength: 0.4, radius: 0.7 },\n    curvature: { amount: 0.04 },\n    noise: { intensity: 0.06, flickerIntensity: 0.04 },\n  },\n\n  pvm: {\n    phosphor: { style: 'pvm', scale: 0.8, intensity: 0.3 },\n    scanlines: { intensity: 0.25, count: 1000, sharpness: 0.5 },\n    bloom: { radius: 2, strength: 0.15, threshold: 0.85 },\n    chromatic: { offset: 0.5 },\n    vignette: { strength: 0.1, radius: 0.9 },\n    noise: { intensity: 0.005, flickerIntensity: 0.005 },\n  },\n\n  vhs: {\n    phosphor: { style: 'composite', scale: 1.2, intensity: 0.4 },\n    scanlines: { intensity: 0.2, count: 500, sharpness: 0.2 },\n    colorBleed: { amount: 0.01, direction: 0 },\n    chromatic: { offset: 4.0 },\n    noise: { intensity: 0.12, flickerIntensity: 0.08, speed: 2.0 },\n    vignette: { strength: 0.2, radius: 0.75 },\n  },\n\n  terminal: {\n    phosphor: { style: 'mono-green', scale: 1.0, intensity: 0.8 },\n    scanlines: { intensity: 0.6, count: 900, sharpness: 0.6 },\n    bloom: { radius: 5, strength: 0.5, threshold: 0.5 },\n    curvature: { amount: 0.03 },\n    vignette: { strength: 0.3, radius: 0.8 },\n    noise: { intensity: 0.04, flickerIntensity: 0.02 },\n  },\n\n  amberTerminal: {\n    phosphor: { style: 'mono-amber', scale: 1.0, intensity: 0.8 },\n    scanlines: { intensity: 0.6, count: 900, sharpness: 0.6 },\n    bloom: { radius: 5, strength: 0.5, threshold: 0.5 },\n    curvature: { amount: 0.03 },\n    vignette: { strength: 0.3, radius: 0.8 },\n    noise: { intensity: 0.04, flickerIntensity: 0.02 },\n  },\n\n  consumer90s: {\n    phosphor: { style: 'slot-mask', scale: 1.3, intensity: 0.5 },\n    scanlines: { intensity: 0.5, count: 700, sharpness: 0.4 },\n    vignette: { strength: 0.5, radius: 0.65 },\n    curvature: { amount: 0.03 },\n    noise: { intensity: 0.04, flickerIntensity: 0.03 },\n    chromatic: { offset: 2.0 },\n    colorBleed: { amount: 0.003 },\n  },\n\n  pcMonitor: {\n    phosphor: { style: 'vga', scale: 1.0, intensity: 0.35 },\n    scanlines: { intensity: 0.2, count: 1080, sharpness: 0.6 },\n    bloom: { radius: 2, strength: 0.1, threshold: 0.9 },\n    vignette: { strength: 0.1, radius: 0.9 },\n    curvature: { amount: 0.01 },\n    noise: { intensity: 0.01, flickerIntensity: 0.005 },\n  },\n\n  retrogaming: {\n    phosphor: { style: 'shadow-mask', scale: 1.2, intensity: 0.5 },\n    scanlines: { intensity: 0.5, count: 480, sharpness: 0.5 },\n    bloom: { radius: 3, strength: 0.25, threshold: 0.7 },\n    chromatic: { offset: 1.5 },\n    vignette: { strength: 0.25, radius: 0.8 },\n    curvature: { amount: 0.02 },\n    noise: { intensity: 0.03, flickerIntensity: 0.02 },\n  },\n\n  cinematic: {\n    phosphor: { style: 'aperture-grille', scale: 0.9, intensity: 0.25 },\n    scanlines: { intensity: 0.15, count: 1080, sharpness: 0.3 },\n    bloom: { radius: 6, strength: 0.4, threshold: 0.6 },\n    vignette: { strength: 0.6, radius: 0.6 },\n    curvature: { amount: 0.005 },\n    chromatic: { offset: 0.8 },\n    noise: { intensity: 0.015, flickerIntensity: 0.01 },\n  },\n};\n",
    "import { Renderer } from './core/renderer.js';\nimport { exportBlob, exportDataURL, exportToCanvas } from './export.js';\nimport type { CRTOptions, ImageSource } from './types.js';\n\nexport class CRTEffect {\n  private renderer: Renderer;\n\n  constructor(canvas: HTMLCanvasElement, options: CRTOptions = {}) {\n    this.renderer = new Renderer(canvas, options);\n  }\n\n  /** Load an image source to apply effects to */\n  async loadImage(source: ImageSource): Promise<void> {\n    return this.renderer.loadImage(source);\n  }\n\n  /** Start the animation loop (for time-based effects like noise/flicker) */\n  start(): void {\n    this.renderer.start();\n  }\n\n  /** Stop the animation loop */\n  stop(): void {\n    this.renderer.stop();\n  }\n\n  /** Render a single frame */\n  renderOnce(): void {\n    this.renderer.renderOnce();\n  }\n\n  /** Deep-merge update options (add, modify, or disable effects) */\n  update(options: CRTOptions): void {\n    this.renderer.updateParams(options);\n    this.renderer.renderOnce();\n  }\n\n  /** Replace all options */\n  setOptions(options: CRTOptions): void {\n    this.renderer.setOptions(options);\n    this.renderer.renderOnce();\n  }\n\n  /** Export as Blob */\n  async exportBlob(mimeType: string = 'image/png', quality?: number): Promise<Blob> {\n    this.renderer.renderOnce();\n    return exportBlob(this.renderer.canvas, mimeType, quality);\n  }\n\n  /** Export as data URL */\n  exportDataURL(mimeType: string = 'image/png', quality?: number): string {\n    this.renderer.renderOnce();\n    return exportDataURL(this.renderer.canvas, mimeType, quality);\n  }\n\n  /** Copy rendered output to another canvas */\n  exportToCanvas(target?: HTMLCanvasElement): HTMLCanvasElement {\n    this.renderer.renderOnce();\n    return exportToCanvas(this.renderer.canvas, target);\n  }\n\n  /** Get the underlying canvas element */\n  get canvas(): HTMLCanvasElement {\n    return this.renderer.canvas;\n  }\n\n  /** Cleanup all WebGL resources */\n  dispose(): void {\n    this.renderer.dispose();\n  }\n}\n\n// Re-export everything\nexport { presets } from './presets.js';\nexport { allEffects } from './effects/index.js';\nexport {\n  scanlines,\n  phosphor,\n  chromatic,\n  bloom,\n  vignette,\n  curvature,\n  noise,\n  colorBleed,\n} from './effects/index.js';\nexport { exportBlob, exportDataURL, exportToCanvas } from './export.js';\nexport type {\n  CRTOptions,\n  ImageSource,\n  Effect,\n  MultiPassEffect,\n  PhosphorStyle,\n  ScanlineParams,\n  ChromaticParams,\n  BloomParams,\n  PhosphorParams,\n  NoiseParams,\n  VignetteParams,\n  CurvatureParams,\n  ColorBleedParams,\n} from './types.js';\n"
  ],
  "mappings": "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,IACb,OAAO;AAAA,IACP,OAAO;AAAA,IACP,WAAW;AAAA,EACb;AAAA,EAEA,gBAAgB;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AA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",
  "debugId": "2FEC87DB4BF4FAEF64756E2164756E21",
  "names": []
}